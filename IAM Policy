import json
import boto3
import logging
import re

log = logging.getLogger()
log.setLevel(logging.INFO)

client_bedrock = boto3.client('bedrock-agent-runtime', region_name='us-east-1')

POPULATION_KB_MAP = {
    "AMGMT99": "RIBHZRVAQA",
    "BLKACTIVE": "TGZMV97MNY",
    "MWTIBEWACTIVE": "L9JYLI9PBF"
}
DEFAULT_KB_ID = "RIBHZRVAQA"

PROMPT_INSTRUCTIONS = """
You are a question-answering agent. You will be given a list of benefit-plan options and a question.
Your job is to use only the provided retrieval results to answer the question about the provided options.

Strict rules:
 - Always pull data for next year’s plans by default—unless the user explicitly asks for current-year details when multiple years are available.
 - If next-year data is not available, fall back to current-year information.
 - If you cannot find an exact answer for a plan feature in the retrievals, state: “I couldn’t find that.”
 - Do not mention plan IDs—use only each plan’s human-readable description.

Answer format:
 - Organize your response into clearly labeled sections (e.g., **In-Network**, **Out-of-Network**, **Option Summaries**, etc.).
 - For every plan option except the one marked **[ELECTED]**, provide a concise 2–3 sentence summary under its own heading.
 - For the **[ELECTED]** option, include a focused breakdown of its **deductible**, **coinsurance**, and **out-of-pocket maximum**.

Targeted follow-ups:
 - If the user’s question calls out a specific option by name, answer only for that option.

Use this structure on every response to keep plan comparisons clean, consistent, and easy to scan.
"""

def normalize_condition(text, plan_name_map):
    for lower_name, exact_name in plan_name_map.items():
        pattern = r"\b" + re.escape(lower_name) + r"\b"
        text = re.sub(pattern, exact_name, text, flags=re.IGNORECASE)
    return text


def lambda_handler(event, context):
    try:
        raw_body = event.get('body', {})
        body = json.loads(raw_body) if isinstance(raw_body, str) else raw_body

        params = {p['name']: p['value'] for p in body.get('parameters', [])}
        log.info(f"Parsed parameters: {params}")

        population_type = params.get('populationType', '').strip().upper()
        kb_id = POPULATION_KB_MAP.get(population_type, DEFAULT_KB_ID)
        log.info(f"Using Knowledge Base ID: {kb_id} for population type: {population_type or 'Default'}")

        condition = params.get('condition', '').strip()
        available_options = body.get('availableOptions', [])
        elected_option = body.get('electedOption', {})

        if not condition or not available_options:
            log.warning("Request is missing 'condition' or 'availableOptions'.")
            return {
                'statusCode': 400,
                'body': json.dumps({'error': 'Missing condition or availableOptions'})
            }

        # Determine elected_desc from optionId
        elected_desc = None
        for opt in available_options:
            if opt.get('optionId') == elected_option.get('optionId'):
                elected_desc = opt.get('optionDescription')
                break

        # Build list of other available descriptions
        available_list = [opt.get('optionDescription') for opt in available_options
                          if opt.get('optionDescription') != elected_desc]

        # Detect if user asked explicitly about another plan
        asked_desc = None
        all_descs = [opt.get('optionDescription') for opt in available_options]
        for desc in all_descs:
            if re.search(rf"\b{re.escape(desc)}\b", condition, flags=re.IGNORECASE):
                asked_desc = desc
                break

        # Decide focus: use asked_desc (if any), else elected_desc
        focus_desc = asked_desc or elected_desc

        # Normalize any plan mentions in the question text
        plan_name_map = {d.lower(): d for d in all_descs}
        normalized_condition = normalize_condition(condition, plan_name_map)

        # Build the prompt blocks (leave elected/available as-is)
        blocks = []
        blocks.append(f"**Elected Option:** {elected_desc}")
        blocks.append("**Available Options:**")
        for desc in available_list:
            blocks.append(f"- {desc}")
        option_list_block = "\n\n".join(blocks)

        # Phrase the question
        base_q = normalized_condition.rstrip(' ?')
        # If no explicit asked_desc, treat as multi-plan
        if not asked_desc:
            question_text = f"{base_q} for each of these options?"
        else:
            question_text = f"{base_q}?"

        # Assemble final input for Bedrock
        prompt_parts = [PROMPT_INSTRUCTIONS.strip(),
                        "Here are the benefit plan options:",
                        option_list_block]
        # Add focus instruction if user named a plan
        if asked_desc:
            prompt_parts.append(f"**Please answer only for:** {focus_desc}")
        prompt_parts.append("Here is the user's question:")
        prompt_parts.append(question_text)
        final_input_text = "\n\n".join(prompt_parts)

        log.info(f"Final input text for Bedrock:\n{final_input_text}")

        response = client_bedrock.retrieve_and_generate(
            input={'text': final_input_text},
            retrieveAndGenerateConfiguration={
                'type': 'KNOWLEDGE_BASE',
                'knowledgeBaseConfiguration': {
                    'knowledgeBaseId': kb_id,
                    'modelArn': (
                        'arn:aws:bedrock:us-east-1::foundation-model/'
                        'anthropic.claude-3-5-sonnet-20240620-v1:0'
                    ),
                    'retrievalConfiguration': {
                        'vectorSearchConfiguration': {
                            'overrideSearchType': 'HYBRID',
                            'numberOfResults': 60
                        }
                    },
                    'generationConfiguration': {
                        'inferenceConfig': {
                            'textInferenceConfig': {
                                'maxTokens': 1024,
                                'temperature': 0.0,
                                'topP': 1.0
                            }
                        }
                    }
                }
            }
        )

        answer = response['output']['text']
        citations = []
        for cit in response.get('citations', []):
            for ref in cit.get('retrievedReferences', []):
                loc = ref.get('location', {})
                content = ref.get('content', {}).get('text')
                uri = loc.get('s3Location', {}).get('uri')
                if uri and content:
                    citations.append({'source': uri, 'text': content})
                else:
                    log.warning(f"Skipping malformed reference: {ref}")

        return {
            'statusCode': 200,
            'headers': {
                'Content-Type': 'application/json; charset=utf-8',
                'Access-Control-Allow-Origin': '*'
            },
            'body': json.dumps({'message': answer, 'citations': citations}, indent=2)
        }

    except Exception as e:
        log.exception("An error occurred in the lambda_handler")
        return {
            'statusCode': 500,
            'body': json.dumps({'error': str(e)})
        }
