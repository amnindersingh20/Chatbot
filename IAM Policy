import json
import logging
import os

import boto3
from botocore.exceptions import ClientError

# --- Configuration via Environment Variables ---
OTHER_LAMBDA_NAME = os.environ.get("OTHER_LAMBDA_NAME", "my-second-lambda")
REGION_NAME         = os.environ.get("AWS_REGION", "us-east-1")
MODEL_ID            = os.environ.get("BEDROCK_MODEL_ID", "anthropic.claude-sonnet-3.5-v1")

# --- Clients ---
logger        = logging.getLogger()
logger.setLevel(logging.INFO)

bedrock       = boto3.client("bedrock-runtime", region_name=REGION_NAME)
lambda_client = boto3.client("lambda",          region_name=REGION_NAME)

def lambda_handler(event, context):
    """
    Extract key phrases from the 'condition' parameter in event['parameters']
    and forward the full payload along with the extracted phrases.
    """
    # 1) Log the original payload
    logger.info("üì• Received payload: %s", json.dumps(event))

    # 2) Locate the 'condition' parameter
    condition_param = None
    for param in event.get("parameters", []):
        if param.get("name") == "condition":
            condition_param = param
            break

    if not condition_param or not condition_param.get("value"):
        logger.warning("No 'condition' parameter found or empty; skipping extraction.")
        key_phrases = []
    else:
        text = condition_param["value"]
        # ==== Use Bedrock Anthropic Claude to extract key phrases via prompt ====        
        try:
            prompt = (
                "Extract the key phrases from the following condition text. "
                "Respond with a JSON array of strings only."
                f"\n\nCondition Text:\n\"\"\"\n{text}\n\"\"\""
            )
            response = bedrock.invoke_model(
                modelId=MODEL_ID,
                inputStream=json.dumps({"prompt": prompt}).encode("utf-8"),
                contentType="application/json"
            )
            body = response["body"].read().decode("utf-8")
            output = json.loads(body)
            raw_text = output.get("completions", [{}])[0].get("data", {}).get("text", "[]")
            key_phrases = json.loads(raw_text)
            logger.info("‚úÖ Extracted key phrases for 'condition': %s", key_phrases)

        except ClientError as e:
            logger.error("‚ùå Bedrock invocation error: %s", e)
            key_phrases = []
        except (ValueError, json.JSONDecodeError) as e:
            logger.error("‚ùå Failed to parse model output as JSON: %s", e)
            key_phrases = []

    # 3) Annotate the condition parameter and build enriched payload
    enriched = dict(event)  # shallow copy
    enriched_parameters = []
    for param in event.get("parameters", []):
        p = dict(param)
        if p.get("name") == "condition":
            p["keyPhrases"] = key_phrases
        enriched_parameters.append(p)
    enriched["parameters"] = enriched_parameters

    # 4) Log the enriched payload
    logger.info("üì§ Enriched payload: %s", json.dumps(enriched))

    # 5) Invoke downstream Lambda asynchronously
    try:
        invoke_resp = lambda_client.invoke(
            FunctionName   = OTHER_LAMBDA_NAME,
            InvocationType = "Event",
            Payload        = json.dumps(enriched),
        )
        logger.info(
            "üöÄ Successfully invoked '%s' (status code %s)",
            OTHER_LAMBDA_NAME,
            invoke_resp.get("StatusCode")
        )
    except ClientError as e:
        logger.error("‚ùå Failed to invoke '%s': %s", OTHER_LAMBDA_NAME, e)

    # 6) Return a 200 OK with key phrases extracted
    return {
        "statusCode": 200,
        "body": json.dumps({
            "message": "Processed successfully",
            "key_phrases": key_phrases
        })
    }
