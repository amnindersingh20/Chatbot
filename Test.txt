```python
import boto3
import os
import sys
import argparse
from botocore.exceptions import NoCredentialsError, PartialCredentialsError

# Ensure AWS credentials are configured via:
#   Environment variables, AWS CLI (aws configure), or ~/.aws/credentials

def get_comprehend_client():
    """Returns an authenticated Amazon Comprehend client."""
    session = boto3.Session()
    creds = session.get_credentials()
    region = session.region_name or os.environ.get('AWS_DEFAULT_REGION')
    if not creds or not creds.access_key or not creds.secret_key:
        print("ERROR: AWS credentials not found. Configure with AWS CLI or environment variables.")
        sys.exit(1)
    if not region:
        print("ERROR: AWS region not set. Set AWS_DEFAULT_REGION or configure ~/.aws/config.")
        sys.exit(1)
    return session.client('comprehend', region_name=region)


def merge_phrases(phrases, text):
    """
    Merge adjacent or overlapping detected phrases into longer continuous phrases.
    :param phrases: List of dicts with 'Text', 'Score', 'BeginOffset', 'EndOffset'
    :param text: Original text string
    :return: List of (merged_text, avg_score)
    """
    # Sort by BeginOffset
    phrases = sorted(phrases, key=lambda x: x['BeginOffset'])
    merged = []
    for ph in phrases:
        if not merged:
            merged.append(ph.copy())
            continue
        last = merged[-1]
        # If current phrase overlaps or is adjacent (gap <=1), merge
        if ph['BeginOffset'] <= last['EndOffset'] + 1:
            # new end = max
            last['EndOffset'] = max(last['EndOffset'], ph['EndOffset'])
            # accumulate scores
            last['Score'] = (last['Score'] + ph['Score']) / 2
            # update text span
            last['Text'] = text[last['BeginOffset']: last['EndOffset']]
        else:
            merged.append(ph.copy())
    # Return list of (Text, Score)
    return [(p['Text'], p['Score']) for p in merged]


def detect_key_phrases(client, text, language_code='en', min_score=0.0):
    """
    Detect and merge key phrases in the given text, filters by minimum confidence.
    """
    response = client.detect_key_phrases(Text=text, LanguageCode=language_code)
    raw = response.get('KeyPhrases', [])
    # Filter by score first
    filtered = [p for p in raw if p['Score'] >= min_score]
    if not filtered:
        return []
    # Merge adjacent phrases
    merged = merge_phrases(filtered, text)
    return merged


def batch_detect(client, lines, **kwargs):
    results = {}
    for line in lines:
        cleaned = line.strip()
        if not cleaned:
            continue
        results[cleaned] = detect_key_phrases(client, cleaned, **kwargs)
    return results


def parse_args():
    parser = argparse.ArgumentParser(description="Amazon Comprehend Key Phrases Detection with merging")
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('-t', '--text', help="Single text input")
    group.add_argument('-f', '--file', type=argparse.FileType('r'),
                       help="Path to text file (one line per input)")
    parser.add_argument('-l', '--language', default='en',
                        help="Language code (default 'en')")
    parser.add_argument('-s', '--min-score', type=float, default=0.0,
                        help="Minimum confidence score (0.0-1.0)")
    return parser.parse_args()


def main():
    args = parse_args()
    client = get_comprehend_client()

    # Single
    if args.text:
        phrases = detect_key_phrases(
            client,
            args.text,
            language_code=args.language,
            min_score=args.min_score
        )
        print(f"Analyzing: {args.text}\n")
        if phrases:
            print("Detected Merged Key Phrases:")
            for phrase, score in phrases:
                print(f" - {phrase} (Score: {score:.2f})")
        else:
            print("No phrases detected above threshold.")
    else:
        lines = args.file.readlines()
        results = batch_detect(
            client,
            lines,
            language_code=args.language,
            min_score=args.min_score
        )
        for text, phrases in results.items():
            print(f"\nInput: {text}\n")
            if phrases:
                print(" Phrases:")
                for phrase, score in phrases:
                    print(f"  - {phrase} (Score: {score:.2f})")
            else:
                print("  No phrases detected above threshold.")

if __name__ == '__main__':
    main()
```
