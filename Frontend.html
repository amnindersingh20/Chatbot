#!/usr/bin/env python3
"""
Simple GUI to filter a target file (CSV or TXT) by employee IDs from a reference CSV.
Provides file pickers using native dialogs, options for delimiters and target type,
and saves output files (filtered file, removed_log, reference IDs, target IDs) to a chosen folder.
"""
import csv
import re
import os
import tkinter as tk
from tkinter import ttk, filedialog, messagebox
from datetime import datetime

# generate a single timestamp for all output files
timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')


def load_csv_ids(csv_path, delimiter="|"):
    ids = set()
    with open(csv_path, newline='', encoding='utf-8') as f:
        reader = csv.reader(f, delimiter=delimiter)
        for row in reader:
            if not row:
                continue
            emp_id = row[0].strip()
            if re.fullmatch(r"\d{8}", emp_id):
                ids.add(emp_id)
    return ids


def filter_txt_by_id(txt_in, txt_out, removed_log, id_set):
    id_header_re = re.compile(r"^(?P<id>\d{8})")
    all_ids = []
    in_remove = False
    with open(txt_in, 'r', encoding='utf-8') as fin, \
         open(txt_out, 'w', encoding='utf-8') as fout, \
         open(removed_log, 'w', encoding='utf-8') as logf:
        for line in fin:
            m = id_header_re.match(line)
            if m:
                cid = m.group('id')
                all_ids.append(cid)
                in_remove = cid in id_set
            if in_remove:
                logf.write(line)
            else:
                fout.write(line)
    # write target IDs
    tgt_ids = os.path.join(os.path.dirname(txt_out), f"target_ids_{timestamp}.txt")
    with open(tgt_ids, 'w', encoding='utf-8') as tf:
        tf.write(f"# Source: {txt_in}\n")
        for tid in all_ids:
            tf.write(tid + '\n')
    return tgt_ids


def filter_csv_by_id(csv_in, csv_out, removed_log, id_set, delimiter=","):
    target_ids = []
    with open(csv_in, newline='', encoding='utf-8') as fin, \
         open(csv_out, 'w', newline='', encoding='utf-8') as fout, \
         open(removed_log, 'w', newline='', encoding='utf-8') as logf:
        reader = csv.reader(fin, delimiter=delimiter)
        writer = csv.writer(fout, delimiter=delimiter)
        log_writer = csv.writer(logf, delimiter=delimiter)
        # header or first row
        first = next(reader, None)
        if first:
            fid = first[0].strip()
            target_ids.append(fid)
            if not re.fullmatch(r"\d{8}", fid) or fid not in id_set:
                writer.writerow(first)
            else:
                log_writer.writerow(first)
        for row in reader:
            if not row:
                continue
            fid = row[0].strip()
            target_ids.append(fid)
            if re.fullmatch(r"\d{8}", fid) and fid in id_set:
                log_writer.writerow(row)
            else:
                writer.writerow(row)
    tgt_ids = os.path.join(os.path.dirname(csv_out), f"target_ids_{timestamp}.txt")
    with open(tgt_ids, 'w', encoding='utf-8') as tf:
        tf.write(f"# Source: {csv_in}\n")
        for tid in target_ids:
            tf.write(tid + '\n')
    return tgt_ids


def write_reference_ids(ref_path, out_dir, id_set):
    ref_ids_file = os.path.join(out_dir, f"reference_ids_{timestamp}.txt")
    with open(ref_ids_file, 'w', encoding='utf-8') as rf:
        rf.write(f"# Source: {ref_path}\n")
        for eid in sorted(id_set):
            rf.write(eid + '\n')
    return ref_ids_file


def run_processing(ref_csv, target_file, out_dir, target_type, ref_delim, tgt_delim):
    try:
        ids = load_csv_ids(ref_csv, ref_delim)
        ref_ids_file = write_reference_ids(ref_csv, out_dir, ids)
        removed_log = os.path.join(out_dir, f"removed_data_{timestamp}.txt")
        base = os.path.basename(target_file)
        name, _ = os.path.splitext(base)
        ext = 'txt' if target_type == 'txt' else 'csv'
        out_fname = os.path.join(out_dir, f"{name}.{ext}")
        if target_type == 'txt':
            tgt_ids_file = filter_txt_by_id(target_file, out_fname, removed_log, ids)
        else:
            tgt_ids_file = filter_csv_by_id(target_file, out_fname, removed_log, ids, tgt_delim)
        messagebox.showinfo(
            "Success",
            f"Files created in {out_dir}:\n"
            f"• Filtered Output: {out_fname}\n"
            f"• Removed Log: {removed_log}\n"
            f"• Reference IDs: {ref_ids_file}\n"
            f"• Target IDs: {tgt_ids_file}" )
    except Exception as e:
        messagebox.showerror("Error", str(e))


def build_gui():
    root = tk.Tk()
    root.title("Employee ID Filter Tool")
    root.resizable(False, False)
    padding = {'padx': 5, 'pady': 5}

    frm = ttk.Frame(root)
    frm.grid(padx=10, pady=10)

    # Reference CSV
    ttk.Label(frm, text="Reference CSV:").grid(row=0, column=0, sticky='E', **padding)
    ref_entry = ttk.Entry(frm, width=40)
    ref_entry.grid(row=0, column=1, **padding)
    browse_ref = ttk.Button(frm, text="Browse…", command=lambda: ref_entry.delete(0, tk.END) or ref_entry.insert(0, filedialog.askopenfilename(filetypes=[('CSV','*.csv')])))
    browse_ref.grid(row=0, column=2, **padding)

    # Target File
    ttk.Label(frm, text="Target File:").grid(row=1, column=0, sticky='E', **padding)
    tgt_entry = ttk.Entry(frm, width=40)
    tgt_entry.grid(row=1, column=1, **padding)
    browse_tgt = ttk.Button(frm, text="Browse…", command=lambda: tgt_entry.delete(0, tk.END) or tgt_entry.insert(0, filedialog.askopenfilename(filetypes=[('CSV/TXT','*.csv;*.txt')])))
    browse_tgt.grid(row=1, column=2, **padding)

    # Output Folder
    ttk.Label(frm, text="Output Folder:").grid(row=2, column=0, sticky='E', **padding)
    out_entry = ttk.Entry(frm, width=40)
    out_entry.grid(row=2, column=1, **padding)
    browse_out = ttk.Button(frm, text="Browse…", command=lambda: out_entry.delete(0, tk.END) or out_entry.insert(0, filedialog.askdirectory()))
    browse_out.grid(row=2, column=2, **padding)

    # Target Type
    ttk.Label(frm, text="Target Type:").grid(row=3, column=0, sticky='E', **padding)
    tgt_type = tk.StringVar(value='csv')
    type_cb = ttk.Combobox(frm, textvariable=tgt_type, values=['csv','txt'], width=5, state='readonly')
    type_cb.grid(row=3, column=1, sticky='W', **padding)

    # Delimiters
    ttk.Label(frm, text="Ref Delimiter:").grid(row=4, column=0, sticky='E', **padding)
    ref_delim = ttk.Entry(frm, width=5)
    ref_delim.insert(0, '|')
    ref_delim.grid(row=4, column=1, sticky='W', **padding)

    ttk.Label(frm, text="Target Delimiter:").grid(row=5, column=0, sticky='E', **padding)
    tgt_delim = ttk.Entry(frm, width=5)
    tgt_delim.insert(0, ',')
    tgt_delim.grid(row=5, column=1, sticky='W', **padding)

    # Run Button
    run_btn = ttk.Button(frm, text="Run", command=lambda: run_processing(
        ref_entry.get(), tgt_entry.get(), out_entry.get(), tgt_type.get(), ref_delim.get(), tgt_delim.get()
    ))
    run_btn.grid(row=6, column=0, columnspan=3, pady=10)

    root.mainloop()

if __name__ == '__main__':
    build_gui()
