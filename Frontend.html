import logging
import json
import re
import difflib
from io import StringIO
import boto3
from datetime import datetime, timezone
import pandas as pd
import time

log = logging.getLogger()
log.setLevel(logging.INFO)

S3_BUCKET = "pocbotai"
S3_KEY = "2025 Medical HPCC Combined.csv"
FALLBACK_LAMBDA_NAME = "Poc_Bot_lambda1"
BEDROCK_MODEL_ID = "anthropic.claude-3-5-sonnet-20240620-v1:0"

DYNAMODB_TABLE_NAME = "POC-Chatbot-ChatSession"

# AWS Clients
_s3 = boto3.client('s3')
_lambda = boto3.client('lambda')
_bedrock = boto3.client("bedrock-runtime", region_name="us-east-1")
_dynamodb = boto3.resource('dynamodb', region_name="us-east-1")
_dynamodb_table = _dynamodb.Table(DYNAMODB_TABLE_NAME)

# Text normalization utilities
SYNONYMS = {
    r"\bco[\s\-]?pay(ment)?s?\b": "copayment",
    r"\bco[\s\-]?insurance\b": "coinsurance",
    r"\b(oop|out[\s\-]?of[\s\-]?pocket)\b": "out of pocket",
    r"\bdeductible(s)?\b": "deductible"
}

def normalize(text: str) -> str:
    # Changed: Also removes extra spaces after normalization for consistent comparison
    return re.sub(r'\s+', '', re.sub(r'[^a-z0-9]', '', str(text).lower()))

def strip_filler(text: str) -> str:
    text = re.sub(r"[^\w\s]", "", text.lower().strip())
    fillers = [
        r"\bwhat('?s)?\b", r"\bwhats\b", r"\bwhat is\b", r"\bwhat is the\b",
        r"\bis the\b", r"\btell me\b", r"\bgive me\b", r"\bplease show\b",
        r"\bhelp me with\b", r"\bhelp me to\b", r"\bhow much is\b", r"\bis\b",
        r"\bmy\b"
    ]
    for pat in fillers:
        text = re.sub(pat, '', text).strip()
    return re.sub(r'\s+', ' ', text)

def expand_synonyms(text: str) -> str:
    for pat, rep in SYNONYMS.items():
        text = re.sub(pat, rep, text, flags=re.IGNORECASE)
    return text

def load_dataframe():
    try:
        obj = _s3.get_object(Bucket=S3_BUCKET, Key=S3_KEY)
        df = pd.read_csv(StringIO(obj['Body'].read().decode('utf-8')), dtype=str)
        df.columns = df.columns.str.strip()
        df['Data Point Name'] = (
            df['Data Point Name'].astype(str)
              .str.replace('–', '-', regex=False)
              .str.replace('\u200b', '', regex=False)
              .str.strip().str.lower()
        )
        df['normalized_name'] = df['Data Point Name'].apply(normalize)
        return df
    except Exception:
        log.exception("Failed to load CSV from S3")
        return pd.DataFrame()

DF = load_dataframe()

def get_plan_value(raw_condition: str, plan_id: str):
    stripped = strip_filler(raw_condition)
    expanded = expand_synonyms(stripped)
    query_norm = normalize(expanded)
    log.info("Lookup trace: raw=%r → stripped=%r → expanded=%r → norm=%r",
             raw_condition, stripped, expanded, query_norm)

    if 'Data Point Name' not in DF.columns or plan_id not in DF.columns:
        return 500, f"CSV missing required columns or plan '{plan_id}'"

    matches = DF[DF['normalized_name'].str.contains(query_norm, na=False)]
    if matches.empty:
        close = difflib.get_close_matches(
            query_norm, DF['normalized_name'].tolist(), n=5, cutoff=0.7
        )
        matches = DF[DF['normalized_name'].isin(close)] if close else matches

    if matches.empty:
        return 404, f"No data-points matching '{raw_condition}' found"

    results = []
    for _, row in matches.iterrows():
        val = row.get(plan_id)
        if pd.notna(val):
            results.append({
                "condition": row['Data Point Name'],
                "plan": plan_id,
                "value": val
            })

    if not results:
        return 404, f"No value for '{raw_condition}' under plan '{plan_id}'"
    return 200, results

def summarize_with_claude35(composite_result: list, options: list, elected: dict) -> str:
    # Filter out "No Coverage" options from the summarization prompt
    filtered_options = [
        {"optionId": opt["optionId"], "optionDescription": opt["optionDescription"]}
        for opt in options if opt.get("optionDescription", "").lower() != "no coverage"
    ]

    # Filter out "No Coverage" data from composite_result before sending to LLM
    filtered_composite_result = [
        item for item in composite_result
        if item.get("optionDescription", "").lower() != "no coverage"
    ]

    elected_desc = (elected or {}).get("optionDescription")
    
    # Ensure elected_desc is not "No Coverage" when passed to prompt
    if elected_desc and elected_desc.lower() == "no coverage":
        elected_desc = "No specific option was elected or it represents no coverage."


    prompt = f"""
You are a helpful and friendly health benefits advisor.
Here are the available options:
{json.dumps(filtered_options, indent=2)}
The employee elected: {elected_desc}.

Retrieved plan data:
{json.dumps(filtered_composite_result, indent=2)}

Your job:
- Summarize each available option as its own section, using its optionDescription.
- Clearly mark which option was elected and which are other available options.
- Within each section, organize In-Network (Individual, Family) and Out-of-Network (Individual, Family) details for each plan.
- Include details like deductibles, coinsurance, out-of-pocket maximums, etc.
- Do not display plan IDs in parentheses after the description.
- Do not display anything of the "No Coverage" option data in the response.
- Do not display that you asked to summarize.
- Use conversational, reader-friendly language and end with a call for further questions.
"""
    try:
        response = _bedrock.invoke_model(
            modelId=BEDROCK_MODEL_ID,
            contentType="application/json",
            accept="application/json",
            body=json.dumps({
                "anthropic_version": "bedrock-2023-05-31",
                "messages": [{"role": "user", "content": prompt}],
                "max_tokens": 1024,
                "temperature": 0.5
            })
        )
        body = json.loads(response['body'].read())
        return body['content'][0]['text']
    except Exception:
        log.exception("LLM summarization failed")
        return None

def wrap_response(status, body):
    return {
        "statusCode": status,
        "headers": {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Methods": "OPTIONS,POST"
        },
        "body": json.dumps(body)
    }

def invoke_fallback(event_payload):
    log.info("Invoking fallback lambda")
    try:
        resp = _lambda.invoke(
            FunctionName=FALLBACK_LAMBDA_NAME,
            InvocationType="RequestResponse",
            Payload=json.dumps(event_payload).encode()
        )
        return wrap_response(200, json.loads(resp['Payload'].read()))
    except Exception as e:
        log.exception("Fallback invocation failed")
        return wrap_response(500, {"error": f"Fallback error: {e}"})

def save_chat_history(session_id: str, user_input: str, bot_response: str):
    timestamp = int(time.time())
    created_at = datetime.now(timezone.utc).isoformat()
    try:
        _dynamodb_table.put_item(
            Item={
                'SessionId': session_id,
                'Timestamp': timestamp,
                'user_input': user_input,
                'bot_response': bot_response,
                'CreatedAt': created_at
            }
        )
        log.info(f"Chat history saved for session {session_id} at {timestamp}")
    except Exception:
        log.exception(f"Failed to save chat history for session {session_id}")

def get_chat_history(session_id: str, limit: int = 5) -> list:
    try:
        response = _dynamodb_table.query(
            KeyConditionExpression='SessionId = :sid',
            ExpressionAttributeValues={':sid': session_id},
            Limit=limit,
            ScanIndexForward=False
        )
        items = response.get('Items', [])
        sorted_items = sorted(items, key=lambda x: x.get('Timestamp', 0))
        log.info(f"Retrieved {len(sorted_items)} chat history items for session {session_id}")
        return sorted_items
    except Exception:
        log.exception(f"Failed to retrieve chat history for session {session_id}")
        return []

def lambda_handler(event, _context):
    log.info("Received event: %s", json.dumps(event))

    # ——— Unwrap body (handles both API‑Gateway JSON-string and direct dict) ———
    raw_body = event.get("body", {})
    if isinstance(raw_body, str):
        try:
            payload = json.loads(raw_body)
        except json.JSONDecodeError:
            return wrap_response(400, {"error": "Invalid JSON in body"})
    else:
        payload = raw_body

    session_id = payload.get("SessionId", "default-session")

    # ——— Extract and normalize parameters ———
    params = payload.get("parameters", [])
    if isinstance(params, dict):
        params = [{"name": k, "value": v} for k, v in params.items()]

    condition = next((p["value"] for p in params if p["name"] == "condition"), None)
    plans = [str(p["value"]).strip() for p in params if p["name"] == "plan"]

    # ——— NEW: user_input_text falls back to condition if inputText missing ———
    user_input_text = payload.get("inputText") or condition or ""

    available_options = payload.get("availableOptions", [])
    elected_option = payload.get("electedOption")

    if not condition and not user_input_text:
        return wrap_response(400, {"error": "Missing 'condition' parameter or 'inputText' in payload"})
    if not plans:
        return wrap_response(400, {"error": "Missing 'plan' parameter(s)"})

    chat_history = get_chat_history(session_id)
    log.info(f"Current chat history for {session_id}: {chat_history}")

    # --- NEW: Check chat history for exact match before processing ---
    normalized_current_input = normalize(user_input_text)
    for turn in chat_history:
        if 'user_input' in turn and 'bot_response' in turn:
            normalized_past_input = normalize(turn['user_input'])
            if normalized_past_input == normalized_current_input:
                log.info(f"Exact match found in chat history for input: '{user_input_text}'. Returning cached response.")
                # We return the cached message directly.
                # Note: `results` will be empty in this case as we're not re-generating it.
                # If you need to store and retrieve past `results`, you'd need to save them in DynamoDB.
                return wrap_response(200, {
                    "message":          turn['bot_response'],
                    "availableOptions": available_options, # Pass through for context
                    "electedOption":    elected_option,    # Pass through for context
                    "results":          [] # Cached responses don't carry 'results' data by default
                })
    # --- END NEW ---

    plan_desc_map = {
        str(opt.get("optionId")): opt.get("optionDescription")
        for opt in available_options
    }
    if isinstance(elected_option, dict):
        plan_desc_map[str(elected_option.get("optionId"))] = elected_option.get("optionDescription")

    composite = []
    response_message = ""

    for plan in plans:
        desc = plan_desc_map.get(plan, "").strip()
        if desc.lower() == "no coverage":
            log.info(f"Skipping plan {plan} due to no coverage")
            continue

        status, data = get_plan_value(condition, plan)
        if status != 200:
            log.warning(f"Lookup failed for plan {plan}. Falling back…")
            fallback_body = {
                "parameters": [
                    {"name": "condition", "value": condition},
                    {"name": "optionDescription", "value": desc or plan},
                    {"name": "populationType", "value": payload.get("populationType")},
                    {"name": "userQuery", "value": user_input_text}
                ],
                "availableOptions": available_options,
                "electedOption":    elected_option,
                "chatHistory":      chat_history # Pass full history for fallback context
            }
            fallback_response = invoke_fallback({ "body": json.dumps(fallback_body) })
            # Save the fallback response to chat history
            save_chat_history(session_id, user_input_text, fallback_response.get('body'))
            return fallback_response

        composite.append({
            "optionId": plan,
            "optionDescription": desc,
            "data": data
        })

    if not composite:
        response_message = "No applicable plans to process based on your query or elected options."
        save_chat_history(session_id, user_input_text, response_message)
        return wrap_response(200, {"message": response_message, "results": []})

    summary = summarize_with_claude35(composite, available_options, elected_option)
    response_message = summary or "I couldn't generate a summary at this time, but here are the raw details."

    # Save the final, non-cached response to chat history
    save_chat_history(session_id, user_input_text, response_message)

    return wrap_response(200, {
        "message":          response_message,
        "availableOptions": available_options,
        "electedOption":    elected_option,
        "results":          composite
    })
