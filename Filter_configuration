import pandas as pd

def syntax_review(text, refValues, fieldList, excel_path='debug_logs.xlsx'):
    """
    Same behavior as your original syntax_review but collects diagnostic logs
    into an Excel file (excel_path) in addition to returning (syntaxErrors, missingRefs).
    Minimal changes to logic; logs are written at the end. If saving fails, the function
    still returns the results.
    """
    logs = []
    syntaxErrors = []
    missingRefs = []

    def safe_len(obj):
        try:
            return len(obj)
        except Exception:
            return None

    # Checks the definition for a list of common issues
    badStrings = ['”', '“', '=', 'NE True', 'EQ true', 'EQ false']
    for badSring in badStrings:
        if badSring in text:
            msg = 'Check definition for: ' + badSring
            syntaxErrors.append(msg)
            logs.append({'stage':'bad_string', 'detail': badSring, 'message': msg})

    # Checks that all brackets have an open and close
    brackets = [{'open':'(', 'close':')'}, {'open':'[', 'close':']'},
                {'open':'{', 'close':'}'}, {'open':'<', 'close':'>'}]
    try:
        for bracket in brackets:
            openNum = text.count(bracket['open'])
            closeNum = text.count(bracket['close'])
            if openNum > closeNum:
                msg = '"' + bracket['close'] + '" missing'
                syntaxErrors.append(msg)
                logs.append({'stage':'bracket_check', 'detail': f"open={bracket['open']},close={bracket['close']}",
                             'message': msg, 'open_count': openNum, 'close_count': closeNum})
            elif openNum < closeNum:
                msg = '"' + bracket['open'] + '" missing'
                syntaxErrors.append(msg)
                logs.append({'stage':'bracket_check', 'detail': f"open={bracket['open']},close={bracket['close']}",
                             'message': msg, 'open_count': openNum, 'close_count': closeNum})

        if text.count('"') % 2 != 0:
            msg = 'Quote is missing'
            syntaxErrors.append(msg)
            logs.append({'stage':'quote_check', 'message': msg, 'quote_count': text.count('"')})
    except Exception as e:
        logs.append({'stage':'bracket_error', 'message': str(e)})

    # Checks that References are in back of the specs
    try:
        logs.append({'stage':'refValues_summary', 'message': repr(refValues), 'type': str(type(refValues)), 'len': safe_len(refValues)})
        logs.append({'stage':'fieldList_summary', 'message': repr(fieldList), 'type': str(type(fieldList)), 'len': safe_len(fieldList)})

        # Per-item diagnostics for refValues
        if refValues is not None:
            for r in refValues:
                try:
                    r_str = str(r)
                    last_chars = r_str[-6:] if len(r_str) >= 6 else r_str
                    last_chars_pairs = [(c, ord(c)) for c in last_chars]
                    ue = r_str.encode('unicode_escape').decode('ascii')
                    logs.append({
                        'stage':'ref_item',
                        'repr': repr(r_str),
                        'len': len(r_str),
                        'last_chars': last_chars,
                        'last_codes': str(last_chars_pairs),
                        'unicode_escape': ue
                    })
                except Exception as e:
                    logs.append({'stage':'ref_item_error', 'repr': repr(r), 'error': str(e)})

        # Per-item diagnostics for fieldList
        if fieldList is not None:
            for f in fieldList:
                try:
                    f_str = str(f)
                    last_chars_f = f_str[-6:] if len(f_str) >= 6 else f_str
                    last_chars_pairs_f = [(c, ord(c)) for c in last_chars_f]
                    ue_f = f_str.encode('unicode_escape').decode('ascii')
                    logs.append({
                        'stage':'field_item',
                        'repr': repr(f_str),
                        'len': len(f_str),
                        'last_chars': last_chars_f,
                        'last_codes': str(last_chars_pairs_f),
                        'unicode_escape': ue_f
                    })
                except Exception as e:
                    logs.append({'stage':'field_item_error', 'repr': repr(f), 'error': str(e)})

        # Membership checks and recording missing refs
        if refValues is not None:
            for reference in refValues:
                try:
                    if reference not in fieldList:
                        msg = reference + ' not in the back of specs'
                        missingRefs.append(msg)
                        logs.append({'stage':'missing_ref', 'message': msg})
                    else:
                        logs.append({'stage':'matched_ref', 'message': f'{reference} matched in fieldList'})
                except Exception as e:
                    logs.append({'stage':'membership_check_error', 'reference_repr': repr(reference), 'error': str(e)})

    except Exception as e:
        logs.append({'stage':'ref_check_error', 'message': str(e)})

    # Save logs into an Excel file
    try:
        df = pd.DataFrame(logs)
        # prefer a consistent column order if present
        cols = ['stage', 'repr', 'message', 'detail', 'type', 'len', 'last_chars', 'last_codes', 'unicode_escape',
                'open_count', 'close_count', 'quote_count', 'error']
        cols_present = [c for c in cols if c in df.columns]
        df = df[cols_present]
        df.to_excel(excel_path, index=False)
    except Exception as e:
        # if saving fails, capture the error in logs but don't raise
        logs.append({'stage':'export_error', 'message': str(e)})

    return syntaxErrors, missingRefs
