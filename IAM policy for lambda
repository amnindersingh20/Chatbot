[ERROR]	2025-07-10T16:24:16.488Z	32447e25-7af1-438e-b6fe-41ca8f7344aa	‚ùå Failed to invoke 'Poc_Bot_lambda2': An error occurred (AccessDeniedException) when calling the Invoke operation: User: arn:aws:sts::653858776174:assumed-role/pocBotPandasQuery-role-rnavlka9/pocBotPandasQuery is not authorized to perform: lambda:InvokeFunction on resource: arn:aws:lambda:us-east-1:653858776174:function:Poc_Bot_lambda2 because no identity-based policy allows the lambda:InvokeFunction action
END RequestId: 32447e25-7af1-438e-b6fe-41ca8f7344aa


import json
import logging
import os

import boto3
from botocore.exceptions import ClientError

# --- Configuration via Environment Variables ---
OTHER_LAMBDA_NAME = os.environ.get("OTHER_LAMBDA_NAME", "Poc_Bot_lambda2")
REGION_NAME      = os.environ.get("AWS_REGION", "us-east-1")
MODEL_ID         = os.environ.get("BEDROCK_MODEL_ID", "anthropic.claude-3-5-sonnet-20240620-v1:0")

# --- Logger Setup ---
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# --- AWS Clients ---
bedrock       = boto3.client("bedrock-runtime", region_name=REGION_NAME)
lambda_client = boto3.client("lambda",          region_name=REGION_NAME)

def lambda_handler(event, context):
    """
    Extract key phrases from the 'condition' parameter in event['parameters']
    and forward the full payload along with the extracted phrases.
    """
    # 1) Log the original payload
    logger.info("üì• Received payload: %s", json.dumps(event))

    # 2) Locate the 'condition' parameter
    condition_param = next(
        (p for p in event.get("parameters", []) if p.get("name") == "condition"),
        None
    )

    if not condition_param or not condition_param.get("value"):
        logger.warning("No 'condition' parameter found or empty; skipping extraction.")
        key_phrases = []
    else:
        text = condition_param["value"]
        # ==== Use Bedrock Anthropic Claude via Chat API ====        
        try:
            prompt = (
                "Extract the key phrases from the following condition text. "
                "Respond with a JSON array of strings only."
                f"\n\nCondition Text:\n\"\"\"\n{text}\n\"\"\""
            )
            # Construct chat payload with required 'messages' key
            response = bedrock.invoke_model(
                modelId=MODEL_ID,
                contentType="application/json",
                accept="application/json",
                body=json.dumps({
                    "anthropic_version": "bedrock-2023-05-31",
                    "messages": [{"role": "user", "content": prompt}],
                    "max_tokens": 1024,
                    "temperature": 0.5
                })
        )
            # Parse response body
            body_bytes = response.get("body").read()
            body_str   = body_bytes.decode("utf-8")
            output     = json.loads(body_str)
            # Depending on API, extract content from first choice or completion
            # Here we handle 'completions' structure
            raw_text = output.get("completions", [{}])[0].get("data", {}).get("text", "[]")
            key_phrases = json.loads(raw_text)
            logger.info("‚úÖ Extracted key phrases for 'condition': %s", key_phrases)

        except ClientError as e:
            logger.error("‚ùå Bedrock invocation error: %s", e)
            key_phrases = []
        except (ValueError, json.JSONDecodeError) as e:
            logger.error("‚ùå Failed to parse model output as JSON: %s", e)
            key_phrases = []

    # 3) Annotate the condition parameter and build enriched payload
    enriched = dict(event)
    enriched_parameters = []
    for p in event.get("parameters", []):
        item = dict(p)
        if item.get("name") == "condition":
            item["keyPhrases"] = key_phrases
        enriched_parameters.append(item)
    enriched["parameters"] = enriched_parameters

    # 4) Log the enriched payload
    logger.info("üì§ Enriched payload: %s", json.dumps(enriched))

    # 5) Invoke downstream Lambda asynchronously
    try:
        invoke_resp = lambda_client.invoke(
            FunctionName   = OTHER_LAMBDA_NAME,
            InvocationType = "Event",
            Payload        = json.dumps(enriched),
        )
        logger.info(
            "üöÄ Successfully invoked '%s' (status code %s)",
            OTHER_LAMBDA_NAME,
            invoke_resp.get("StatusCode")
        )
    except ClientError as e:
        logger.error("‚ùå Failed to invoke '%s': %s", OTHER_LAMBDA_NAME, e)

    # 6) Return a 200 OK with key phrases extracted
    return {
        "statusCode": 200,
        "body": json.dumps({
            "message": "Processed successfully",
            "key_phrases": key_phrases
        })
    }
[INFO]	2025-07-10T16:24:16.254Z	32447e25-7af1-438e-b6fe-41ca8f7344aa	‚úÖ Extracted key phrases for 'condition': []
